{
  "items": [
    {
      "kbID": 1,
      "title": "Filename injection Path traversal",
      "content": " Description:\n\nA Path Traversal attack aims to access files and directories that are stored outside the web root folder. By browsing the application, the attacker looks for absolute links to files stored on the web server. By manipulating variables that reference files with dotdotslash (../); sequences and its variations, it may be possible to access arbitrary files and directories stored on file system, including application source code, configuration, and critical system files, limited by system operational access control. The attacker uses  ../../ sequences to move up to root directory, thus permitting navigation through the file system. This attack can be executed with an external malicious code injected on the path, like the Resource Injection attack.\n\n\n Solution:\n\nThe most effective solution to eliminate file inclusion vulnerabilities is to avoid passing\nusersubmitted input to any filesystem/framework API. If this is not possible the application\ncan maintain a white list of files, that may be included on the page, and then use an identifier\n(for example the index number) to access the selected file. Any request containing an invalid\nidentifier has to be rejected, in this way there is no attack surface for malicious users to\nmanipulate the path.\n\n"
    },
    {
      "kbID": 3,
      "title": "XSS injection",
      "content": " Description:\n\nEvery time the application gets userinput, whether this showing it on screen or processing\nthis data in the application background, these parameters should be escaped for malicious\ncode in order to prevent crosssite scripting injections.\nWhen an attacker gains the possibility to perform an XSS injection,\nhe is given the opportunity to inject HTML and JavaScript code directly into the\napplication. This could lead to accounts being compromised by stealing session cookies or directly affect the operation of the target application. \n\n Solution:\n\nIn order to prevent XSS injections, all userinput should be escaped or encoded.\nYou could start by sanitizing userinput as soon as it is inserted into the application,\nby preference using a so called whitelisting method.\nThis means you should not check for malicious content like the tags or anything,\nbut only allow the expected input. Every input which is outside of the intended operation\nof the application should immediately be detected and login rejected.\nDo not try to help use the input in any way because that could introduce a new type of attack by converting characters. \n\nThe second step would be encoding all the parameters or userinput before putting this in\nyour html with encoding libraries specially designed for this purpose.\n\nYou should take into consideration that there are several contexts for encoding userinput for\nescaping XSS injections. These contexts are amongst others:\n\nHTML encoding is for whenever your userinput is displayed directly into your HTML.\nHTML attribute encoding is the type of encoding/escaping that should be applied whenever your user input is displayed into the attribute of your HTML tags.\nHTML URL encoding ;This type of encoding/escaping should be applied to whenever you are using userinput into a HREF tag.\n\nJavaScript encoding should be used whenever parameters are rendered via JavaScript; your application will detect normal injections in the first instant. But your application still remains vulnerable to JavaScript encoding which will not be detected by the normal encoding/escaping methods.\n\n"
    },
    {
      "kbID": 4,
      "title": "Command injection",
      "content": " Description:\n\nCommand injection is an attack in which the goal is execution of arbitrary commands on\nthe host operating system via a vulnerable application. Command injection attacks are\npossible when an application passes unsafe user supplied data\n(forms, cookies, HTTP headers etc.) to a system shell. In this attack,\nthe attackersupplied operating system commands are usually executed with the privileges\nof the vulnerable application. Command injection attacks are possible largely due to\ninsufficient input validation. This attack differs from Code Injection, in that code\ninjection allows the attacker to adds his own code that is then executed by the application.\nIn Code Injection, the attacker extends the default functionality of the application\nwithout the necessity of executing system commands.\n\n Solution:\n\nUserinput that is used in a shell command should not contain dangerous characters.\nA blacklist of characters is not a good option because it may be difficult to think of\nall of the characters to validate against. A white list containing only allowable\ncharacters should be created to validate the userinput.\n"
    },
    {
      "kbID": 5,
      "title": "Cross site request forgery",
      "content": " Description:\n\nCrossSite Request Forgery (CSRF) is a type of attack that occurs when a malicious Web site,\nemail, blog, instant message, or program causes a users Web browser to perform an unwanted\naction on a trusted site for which the user is currently authenticated.\n\nThe impact of a successful crosssite request forgery attack is limited to the\ncapabilities exposed by the vulnerable application. For example, this attack could result\nin a transfer of funds, changing a password, or purchasing an item in the users context.\nIn effect, CSRF attacks are used by an attacker to make a target system perform a\nfunction (funds Transfer, form submission etc.) via the targets browser without\nknowledge of the target user at least until the unauthorised function has been committed.\n\n Solution:\n\nTo arm an application against automated attacks and tooling you need to use unique tokens\nwhich are included into the forms of an application, API calls or AJAX requests.  \nAny state changing operation requires a secure random token (e.g CSRF token) to prevent\nagainst CSRF attacks. Characteristics of a CSRF Token are a unique, large random\nvalue generated by a cryptographically secure random number generator.\n\nThe CSRF token is then added as a hidden field for forms and validated on the sever side whenever\na user is sending a request to the server.\n\nNote :\nWhenever the application is an REST service and is using tokens such as JWT tokens, whenever these tokens are being sent\nin the application headers rather than stored in cookies the application should not be suspectible to CSRF attacks for a succesfull CSRF attacke depends on the browsers cookie jar.\n"
    },
    {
      "kbID": 6,
      "title": "XXE injections",
      "content": " Description:\n\nProcessing of an Xml eXternal Entity containing tainted data may lead to the disclosure of\nconfidential information and other system impacts.\nThe XML 1.0 standard defines the structure of an XML document.\nThe standard defines a concept called an entity, which is a storage unit of some type.\n\nThere exists a specific type of entity, an external general parsed entity often shortened\nto an external entity, that can access local or remote content via a declared system\nidentifier and the XML processor may disclose confidential information normally not\naccessible by the application. Attacks can include disclosing local files, which may\ncontain sensitive data such as passwords or private user data.\n\n Solution:\n\nDisable the possibility to fetch resources from an external source.\nThis is normally done in the configuration of the used XML parser.\n"
    },
    {
      "kbID": 7,
      "title": "X Path injections",
      "content": " Description:\n\nWeb applications heavily use databases to store and access the data they need for their\noperations. Historically, relational databases have been by far the most common\ntechnology for data storage, but in the last years, we are witnessing an increasing\npopularity for databases that organise data using the XML language.\nJust like relational databases are accessed via SQL language, XML databases use XPath as\ntheir standard query language.\n\n Solution:\n\nJust like the techniques to avoid SQL injection, you need to use a parameterised XPath\ninterface if one is available, or escape the user input to make it safe to include in a\ndynamically constructed query. If you are using quotes to terminate untrusted input in a\ndynamically constructed XPath query, then you need to escape that quote in the untrusted\ninput to ensure the untrusted data can not try to break\nout of that quoted context.\n"
    },
    {
      "kbID": 8,
      "title": "XML injection",
      "content": " Description:\n\nXML Injection is an attack technique used to manipulate or compromise the logic of an XML\napplication or service. The injection of unintended XML content and/or structures into\nan XML message can alter the intended logic of the application. Further, XML injection\ncan cause the insertion of malicious content into the resulting message/document.\n\n Solution:\n\nIn addition to the existing input validation, define a positive approach which\nescapes/encodes characters that can be interpreted as XML. At a minimum this includes\nthe following: < > / \" '\n"
    },
    {
      "kbID": 9,
      "title": "XSLT injections",
      "content": " Description:\n\nA vulnerability occurs when an XSL file is loaded from a source controlled by an attacker.\nWhen the attacker is given the opportunity to specify the source of the included XSL file\nhe could include a file which contains malicious code to be parsed on the target application.\nThis could lead to, code execution, reading arbitrary files and many more\nvulnerabilities such as XSS.\n\n Solution:\n\nTo protect against such vulnerability one needs to make sure that he does not use\nusersupplied input in the XSL filename.\nThe best solution would be to define a list of permitted filenames and\nonly accept XSL filenames from that list.\n"
    },
    {
      "kbID": 10,
      "title": "External DTD parsing",
      "content": " Description:\n\nProcessing of an external entity containing tainted data may lead to the disclosure of confidential information and other system impacts. The XML 1.0 standard defines the structure of an XML document. The standard defines a concept called an entity, which is a storage unit of some type. There exists a specific type of entity, an external general parsed entity often shortened to an external entity that can access local or remote content via a declared system identifier. The system identifier is assumed to be a URI that can be dereferenced (accessed) by the XML processor when processing the entity.\nThe XML processor then replaces occurrences of the named external entity with the contents dereferenced by the system identifier. If the system identifier contains tainted data and the XML processor dereferences this tainted data, the XML processor may disclose confidential information normally not accessible by the application. Attacks can include disclosing local files, which may contain sensitive data such as passwords or private user data, using file: schemes or relative paths in the system identifier.\nSince the attack occurs relative to the application processing the XML document, an attacker may use this trusted application to pivot to other internal systems, possibly disclosing other internal content via HTTP(s) requests. In some situations, an XML processor library that is vulnerable to clientside memory corruption issues may be exploited by dereferencing a malicious URI, possibly allowing arbitrary code execution under the application account. Other attacks can access local resources that may not stop returning data, possibly impacting application availability if too many threads or processes are not released.\n\n\n Solution:\n\nDisable the XML DTD (Document Type Definition) parsing. This can be set when initiating the XML parser.\n"
    },
    {
      "kbID": 11,
      "title": "LDAP injection",
      "content": " Description:\n\nLDAP (Lightweight Directory Access Protocol) Injection is an attack used to exploit web based applications that construct LDAP statements based on user input. When an application fails to properly sanitize user input, it is possible to modify LDAP statements using a local proxy. This could result in the execution of arbitrary commands such as granting permissions to unauthorized queries, and content modification inside the LDAP tree. The same advanced exploitation techniques available in SQL Injection can be similarly applied in LDAP Injection.\n\n Solution:\n\nThe best way to prevent LDAP injection is to use a positive validation scheme for ensuring that the data going into your queries does not contain any attacks. However, in some cases, it is necessary to include special characters in the input that is passed into an LDAP query. In this case, using escaping can prevent the LDAP interpreter from thinking those special characters are actually part of the LDAP query.\n"
    },
    {
      "kbID": 12,
      "title": "SSI injections",
      "content": " Description:\n\nWeb servers usually give developers the ability to add small pieces of dynamic code inside\nstatic HTML pages, without having to deal with fullfledged serverside\nor clientside languages.\n\nThis feature is incarnated by the ServerSide Includes (SSI).\nThe attacker will try to inject code into the application that will\nbe interpreted by SSI mechanisms. A successful exploitation of this vulnerability\nallows an attacker to inject code into HTML pages or even perform remote code execution.\n\n Solution:\n\nThe SSI handler on the webserver should not be activated when it is not used.\n"
    },
    {
      "kbID": 13,
      "title": "File upload injections",
      "content": " Description:\n\nUploaded files represent a significant risk to applications.\nThe first step in many attacks is to get some code to the system to be attacked.\nThen the attack only needs to find a way to get the code executed. Using a file upload\nhelps the attacker accomplish the first step.\n\nThe consequences of unrestricted file upload can vary, including complete system takeover,\nan overloaded file system or database, forwarding attacks to backend systems, and simple\ndefacement.\n\nThere are really two classes of problems here.\nThe first is with the file metadata, like the path and file name.\nThese are generally provided by the transport, such as HTTP multipart encoding.\nThis data may trick the application into overwriting a critical file or storing the file\nin a bad location. You must validate the metadata extremely carefully before using it.\n\nThe other class of problem is with the file size or content.\nAn attacker can easily craft a valid image file with PHP code inside.\n\n Solution:\n\nUploaded files always need to be placed outside the document root of the webserver.\n\nYou should also check the userinput(filename) for having the right\nallowed extensions such as .jpg, .png etc.\n\nNote: when checking these extensions always make sure your application validates the last\npossible extension so an attacker could not simply inject \".jpg.php\" and bypass your\nvalidation\n\nAfter this validation, you must also check the userinput(filename) for containing possible\npath traversal patterns in order to prevent him from uploading outside of\nthe intended directory.\n\nMost developers also do a mimetype check. This is a good protection however not\nwhenever you are checking this mimetype through the post request. This header can not be\ntrusted since it can be easily manipulated by an attacker.\n\nThe best way to check the mimetype\nis to extract the file from the server after uploading and check it from the file itself.\nDeleting it whenever it does not comply with expected values.\n\nYou may also want to check if the filenames do already exist before uploading in order to\nprevent the overwriting of files.\n\nAlso for serving the files back there needs to be a file handler function that can select\nthe file based on an identifier that will serve the file back towards the user.\n"
} ] 
}